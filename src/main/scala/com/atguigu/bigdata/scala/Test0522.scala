package com.atguigu.bigdata.scala

import scala.util.control.Breaks

object Test0522 {
  def main(args: Array[String]): Unit = {
//    /*
//    回顾:
//    函数和方法的区别：类中功能封装-->方法，一部分逻辑封装-->函数。方法就是函数，函数也可以当方法。
//    函数没重载，重写。
//    至简原则-->return省略、{}省略、能够通过返回值判断类型，返回值类型可以省略、
//    参数列表无参，调用的时候一定不要加、省略等号，明确返回Unit，但是有返回值、
//    省略名称和关键字
//     */
//
//    /*
//    高阶函数编程：
//     */
//
//    //*********************************************************************
//
//    //函数式编程小练习
//    //1.
//    def transform1(num:Int):Int={
//      num * 2
//    }
//
//    //2.
//    def transform2(num:Int,f:(Int)=>Any):Any={
//      f(num)
//    }
//    val result = transform2(5,(d:Int)=>{"这就成了"})
//    println(result)
//    //3.
//    def test(x:Int,y:Int,c:(Int,Int)=>Any) ={
//      c(x,y)
//    }
//
//    test(10,20,_+_)
//
//    //4.
//
//    def filter(a:String,fun:(String)=>Boolean): String ={
//      val words:Array[String] = a.split(" ")
//    }
//
//    filter("Hello world scala spark",(word:String)=>{word.startsWith("s")} )
//
//
//    /*
//    答疑：
//    1.方法参数不能改：函数的参数是不能改的。
//    2.匿名函数后面代码不执行：匿名函数没有只声明不调用的，也就是说必须要加变量
//    3.匿名函数的参数不使用的简化：参数只用一次可以用下划线，必须要使用一次。
//    4.循环的反向操作：5 to 1 by -1
//    5.val a ()=>String = fun ---> fun必须声明的时候带()。赋值给变量后调用就必须加()
//    6.函数作为参数不理解：要考虑作用域问题，
//    7.for循环中的i为什么不声明val或者var：for循环中的i是单独。
//     */
//
//    //************************************************************************
//    //函数作为返回值：
//    def test3(i:Int): Int ={
//      i * 2
//    }
//    def fun()={
//      test3 _
//    }
//
//    //调用函数
//    val a = fun() //当前fun的执行结果为函数，a此时就是函数
//    println(a(10))
//    //简化下
//    println(fun()(10))
//
//    //当我们的函数作为函数的返回值使用时，一般会使用嵌套函数
//    def fun5() ={
//      def test(i:Int):Int={
//        i * 2
//      }
//
//      test _
//    }
//
//    println(fun5()(40))
//
//    //如果不想使用下划线返回对象，那么需要显示声明函数的返回值类型
//    def fun3(): Int=>Int ={
//      def test(i:Int):Int={
//        i * 2
//      }
//
//      test
//    }
//
//    //
//    //java在执行方法的时候会有压栈，弹栈
//    //test先执行
//    //函数在使用外部变量时，如果外部变量失效时，会将这个变量包含到当前的函数内部，形成闭合的使用效果。
//    //改变变量的声明周期，将这种操作称作为closer-->（闭包效果）。
//    //反编译后，发现编译器重新声明了内部函数的参数，2.12版本将我们使用的外部变量作为内部函数的参数使用。
//    //在早期2.11版本，闭包会被编译为匿名函数类。
//    //早期的scala版本即使没使用外部变量，也会有闭包的效果，只是没有包含外部的变量，如果使用外部变量，
//    // 会将外部变量作为类的属性。
//    //spark会如何判断闭包：判断类名中是否为匿名函数类。
//    //
//    //如果没有用到内部函数，那就是没有闭包。
//
//    def test8( i : Int)={
//      def sum(j:Int) ={
//        i + j
//      }
//      sum _
//    }
//
//    test8(10)(20)
//
//    /*
//    new User()创建的对象存在在哪一块内存中
//    如何理解GC：
//    最大的优点不需要人工参与，最大的缺点也是不能人工参与。
//    堆外内存-->操作系统内存-->1/64，JVM Heap + 堆外内存
//    栈上分配，有要求，逃逸分析，
//     */
//    //****************************************************************
//    //演示闭包
//    /*
//    闭包主要的感觉是改变了变量的声明周期
//     */
//
//    val z = 10
//    def test13(): Unit ={
//      val g = z + 10
//      print(g)
//    }
//
//    val c = test13 _
//    //闭包的演示需要重新看一下
//
//    /*
//    函数的柯里化
//    使用函数柯里化的方式声明函数
//    所谓的柯里化，其实就是多个参数列表
//    1.简化嵌套函数的开发
//    2.将复杂的参数逻辑简单化
//
//     */
//    def test()(): Unit ={
//      println("test...")
//    }
//    //调用函数
//    test()()
//
//    //控制抽象
//    for(i <- 1 to 5 ){
//      //捕捉异常
//      Breaks.breakable{
//        if(i == 3){
//          //抛出异常
//          Breaks.break()
//        }
//      }
//      println("i = " + i)
//    }
//    //Breakable是一个函数，参数列表中如果有多行逻辑，可以采用{}代替
//    //scala支持将代码逻辑作为参数传递给函数使用
//    //如果函数参数想要传递代码逻辑，那么类型声明的方式应该为：参数名：=>返回值类型(Unit)
//    //因为参数类型中没有声明小括号，那么调用时也不能有()
//    //控制抽象需要重新看一下
//
//    //初始化环境：数据库、资源文件、数据文件、核心对象的创建
//    //逻辑代码：JDBC、load、readling
//    //环境的关闭和释放
//
//    /*
//    递归：方法执行过程中，调用自身。
//    存在跳出递归的逻辑，可能会出现stackOverflowError(栈溢出)
//    方法调用时，传递的参数之间应该存在规律
//    scala中我们的递归方法需要明确返回值类型，不能省略
//    扩大栈内存大小
//     */
//    //实现阶乘
//    //尾递归：递归的方法不依赖外部的变量
//    //编译器碰见我们的尾递归操作时，会自动优化为循环操作
//
//    //惰性函数：用到数据的时候加载数据，延迟加载功能是编译器在编译时产生大量的方法进行调用所实现的
//
//    //将一个对象转换为另外一个类型的对象




















  }

}
