package com.atguigu.bigdata.scala

import scala.util.control.Breaks

object Test0520 {

//  def main(args: Array[String]): Unit = {
//    //变量有的可以声明但是不能使用
//    val _ = "zhangsan"
//    /*
//    为什么hashcode和equals都要一起重写？
//    往hashmap放数据先判断hashcode再判断equals，某些场合下会先调用hashcode 再调用equals。
//     */
//
//    //运算符本质--->万物皆对象
//
//    //循环守卫：满足条件就可以执行循环体,if前可以加;
//    for ( i <- Range(1,5) if i != 3  ) {
//      println("i = " + i )
//    }
//    //java
//    for ( i <- Range(1,5)  ) {
//      if (i != 3){
//        println("i = " + i )
//      }
//    }
//    //循环嵌套
//    for ( i <- Range(1,5) ) {
//      for ( j <- Range(1,4) ) {
//        println("i = " + i + ",j = " + j )
//      }
//    }
//    //进化版--->和嵌套循环的区别好好体会
//    for ( i <- Range(1,5); j <- Range(1,4) ) {
//      println("i = " + i + ",j = " + j )
//    }
//
//    //引入变量
//    for ( i <- Range(1,5); j = i - 1 ) {
//      println("j = " + j )
//    }
//
//    //一次for循环写杨辉三角
//    val num = 9
////    for(i <- 1 to 2 * num by 2){
////      for(j <- 1 to i){
////        print("*")
////      }
////      println("")
////    }
//
//    for(i <- 1 to 2 * num by 2; j = (18 - i)/2){
//      println(" "* j + "*" * i)
//    }
//
//    //表达式都会有返回值
//    var a = 10
//    //结果是--->()吗，相当于(a = 20)有返回值
//    val b = a = 20
//
//
//    /*for循环的表达式返回值是Unit
//    如果需要获取for循环表达式的具体值，需要使用yield关键字
//    这种操作可以将一个集合转换为另外一个集合
//    开发中不使用
//     */
//
//    //在scala中出现java中的方法的但是是scala的关键字时，系统会自动加上飘号。
//
//    //while 和 do while
//
//    /*
//    循环中断：scala中无法使用break和continue
//    scala采用对象.方法的方式实现中断，使用抛出异常的方式来中断循环
//    将需要中断的循环放置在一个“代码块”中，可以处理异常
//    breakable是一个方法，{}是一个参数列表-->将一段代码作为参数传给一个方法
//     */
//
//    Breaks.breakable{
//      for( i <- 1 to 5){
//        if( i == 3){
//          //中断循环
//          Breaks.break()
//        }
//        println("i =" + i)
//      }
//    }
//    println("hello")
//
//  // 函数式编程***************************************************************************
//    //函数式编程就是封装
//    //函数的声命方式：
//    //def 函数名 (参数列表) [:返回值类型] = {函数体}
//
//    /*
//    函数调用
//    函数名(参数)
//     */
//    test("zhangsan")
//
//    /*
//    函数&方法
//    方法概念来自java
//    函数概念来自scala
//    scala也是完全函数式编程语言--->万物皆函数，所以方法其实就是函数
//    一般情况下将类中封装的功能函数称之为方法--->在类的里面
//    其他地方封装的功能称之为函数--->可以声明在任意地方，同时也可以嵌套
//    类中的函数就是方法，符合java的语法规则：重写和重载
//    函数中没有重写重载的概念
//    类中定义的函数就是方法
//    方法没有嵌套的能力，函数有嵌套的能力。
//     */
//
//
//    // 无参、无返回值
//    def fun1():Unit = {
//      println("fun1...")
//    }
//    fun1()
//    // 无参、有返回值、
//    def fun2():String = {
//      return "zhangsan"
//    }
//    println(fun2())
//    // 有参、无返回值
//    def fun3(s:String):Unit = {
//      println("name = " + s)
//    }
//    fun4("jiayou")
//    // 有参、有返回值
//    def fun4(name:String):String = {
//      return "name =" + name
//    }
//    // 多餐、无返回值
//    def fun5(name:String,age:Int):Unit = {
//      println(
//        s"""
//           |{"username":"$name","age":$age}
//           |""".stripMargin)
//    }
//    // 有参、有返回值
//    def fun6(name:String,age:Int):String = {
//      return s"name = $name,age = $age"
//    }
//    println(fun6("zhangsan",30))
//
//    //函数参数的个数--->最多的个数为22，声明的时候可以超过22，但将我们的函数作为赋值给变量时会报错。
//    //可变参数，相同类型的参数多次出现，但是不确定个数
//    def test( i : Int*): Unit ={
//      println(i)
//    }
//    //可变参数的顺序-->可变参数放置在最后，可变参数不能声明多个
//    def test( i : Int*): Unit ={
//      println(i)
//    }
//
//    /*
//     函数的参数使用的是val声明。无法进行修改
//     scala提供了参数默认值的语法来解决参数默认值的问题
//     */
//    //参数默认值：参数声明时进行初始化
//    def regUser( name : String , password : String = "000000"): Unit ={
//      println("password = " + password)
//    }
//    //如果函数存在默认值的参数，调用时可以不用传递
//    regUser("zhangsan")
//    //如果调用函数时，提供了参数的值，则默认值被覆盖了。如果传递了参数，会覆盖默认值
//    regUser("lisi","123123")
//
//    //函数在传递参数时按照从左到右的方式进行匹配的，
//    def regUser1( name : String , password : String = "000000",tel : String): Unit ={
//      println("password = " + password)
//    }
//    //带名参数：传递参数时添加参数名，明确指定参数
//    regUser1("zhangsan",tel = "123123123")
//
//    //*********************************************************************************
//    //难度加大了--->噩梦版
//    //Scala中函数有至简原则：能省则省。这里的能省则省必须是编译器可以自动推断的场合，才能省
//    /*
//    当函数需要返回值时，可以将函数体中最后一行执行的代码作为返回结果，所以可以省略return关键字
//     */
//    def fun4(name:String):String = {
//      "name =" + name
//    }
//    //如果编译器可以推断出函数的返回值类型，返回值类型可以省略
//    def fun4(name:String)= {
//      "name =" + name
//    }
//    //如果函数体逻辑只有一行代码，{}可以省略
//    def fun4(name:String)= "name =" + name
//    //如果函数的参数没有提供参数，那么调用的时候()可以省略，
//    // 如果函数没有提供参数，那么声明时()可以省略，调用时必须不能使用()--->统一访问原则
//    def fun4 = "zhangsan"
//    println(fun4)
//    //函数如果明确使用Unit声明没有返回值，那么函数体中的return关键字不起作用
//    //函数体中如果明确使用return关键字，那么返回值类型不能省
//    //明确函数没有返回值，又不想声明，怎么办？---> 那么可以同时省略等号，将这种函数的声明方式称之为过程函数，不省略{}
//    def test5() {
//      return "zhangsan"
//    }
//    // ()---> 集合
//    /*
//    当只关心代码逻辑，不关心函数名称时，函数名和def关键字可以省略，将没有名称和def关键字的函数称之为匿名函数
//    规则：(参数列表) => {代码逻辑}
//     */
//    () => println("no name")
//    //函数调用：函数(变量)名称(参数列表)
//      val a = () => println("no name")
//    //调用
//      a()
//    //********************************************************************************
//    //函数式编程--->地狱版
//      //函数可以作为对象赋值给变量,函数也是对象
//    def test1() = {
//      "zhangsna"
//    }
//      //将函数赋值给变量，那么这个变量其实就是函数，可以调用\
//      //f3是个字符串，函数如果没有参数列表，那么调用时可以省略小括号
//      val f3 = test1
//      //如果此时希望将函数不执行，而是当成一个整体赋值给变量，那么需要使用下划线
//      //类型是---> ()=>String
//      /*
//      下划线的用法：
//      下划线可以作为标识符使用
//      下划线可以将函数作为整体来使用
//      下划线在匿名函数中可以代替参数
//       */
//      val f4 = test1 _
//      f4()
//      println(f4())
//      //如果不想使用下划线明确将函数作为整体使用，那么也可以直接声明变量的类型作为函数
//      //函数的类型如何声明： 参数列表=>返回值类型   如：()=>String
//      val f1 : ()=>String = test1
//      val ff1 : (String)=>String = fun4
//      //************************************************************************************
//      //地狱版II
//      //函数可以作为参数传递给其他的函数
//      //函数名(参数名1：参数类型1，参数名2：参数类型2)
//      //函数名(参数名1 ：函数类型)
//      def fun2(i : Int): Int ={
//        i * 2
//      }
//      def test2(f:(Int)=>Int) = {
//        f(10)
//      }
//      //将函数赋值为变量
//      val f = fun2 _
//      test2(f)
//      //将函数作为参数使用时，一般是不关心函数的名称的，所以一般使用匿名函数
//      //匿名函数规则：(参数列表) => {代码逻辑}
//      val result = test2( (i:Int)=>{i*i} )
//      println(result)
//
//      /*
//      至简原则
//      如果逻辑代码只有一行，大括号可以省略
//      如果匿名函数的参数类型可以推断出来，那么类型可以省略
//      如果匿名函数的参数列表只有一个或没有，那么小括号可以省略
//      如果匿名函数中的参数在逻辑代码中只使用了一次，那么参数和=>可以省略
//      使用下划线代替出现
//       */
//      val result2 = test2( _*2 )
//
//
//      //函数可以作为函数的返回值返回
//
//
//
//
//    def fun4(name:String):String = {
//      return "name =" + name
//    }
//
//
//
//
//  }
//
//  //参数声明规则-->参数名：参数类型
//  def test(s : String) : Unit = {
//    //逻辑代码
//    println("s = " + s)
//  }




}


